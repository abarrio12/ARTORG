import numpy as np
import igraph as ig
import pickle

# --------------------------
# Helpers
# --------------------------
def is_inside_box_np(P, xBox, yBox, zBox):
    # P: (N,3)
    return (
        (P[:,0] >= xBox[0]) & (P[:,0] <= xBox[1]) &
        (P[:,1] >= yBox[0]) & (P[:,1] <= yBox[1]) &
        (P[:,2] >= zBox[0]) & (P[:,2] <= zBox[1])
    )

def quant_key(p, tol=1e-4):
    # tol en micras (ajústalo: 1e-4–1e-3 suele ir bien con float32)
    return tuple(np.round(np.asarray(p)/tol).astype(np.int64))

def segment_box_intersection(p_in, p_out, xBox, yBox, zBox):
    """
    Intersección del segmento (p_in -> p_out) con el borde del AABB.
    p_in está dentro, p_out está fuera.
    Devuelve punto de intersección (3,) o None si algo raro.
    """
    p_in = np.asarray(p_in, float)
    p_out = np.asarray(p_out, float)
    d = p_out - p_in

    t_candidates = []

    # Para cada plano x=min/max, y=min/max, z=min/max:
    for axis, (mn, mx) in enumerate([xBox, yBox, zBox]):
        if abs(d[axis]) < 1e-12:
            continue

        # intersección con mn
        t = (mn - p_in[axis]) / d[axis]
        if 0.0 <= t <= 1.0:
            p = p_in + t*d
            if (xBox[0]-1e-6 <= p[0] <= xBox[1]+1e-6 and
                yBox[0]-1e-6 <= p[1] <= yBox[1]+1e-6 and
                zBox[0]-1e-6 <= p[2] <= zBox[1]+1e-6):
                t_candidates.append((t, p))

        # intersección con mx
        t = (mx - p_in[axis]) / d[axis]
        if 0.0 <= t <= 1.0:
            p = p_in + t*d
            if (xBox[0]-1e-6 <= p[0] <= xBox[1]+1e-6 and
                yBox[0]-1e-6 <= p[1] <= yBox[1]+1e-6 and
                zBox[0]-1e-6 <= p[2] <= zBox[1]+1e-6):
                t_candidates.append((t, p))

    if not t_candidates:
        return None

    # Queremos el primer cruce saliendo desde p_in => t mínimo > 0
    t_candidates.sort(key=lambda a: a[0])
    return t_candidates[0][1]

def polyline_length(P):
    if len(P) < 2:
        return 0.0
    d = np.diff(P, axis=0)
    return float(np.sum(np.linalg.norm(d, axis=1)))

# --------------------------
# Main cut
# --------------------------
def cut_outgeom_gaia_like(data, xBox, yBox, zBox, tol=1e-4, min_straight_dist=1.0):
    """
    data: dict con {"graph":G, "coords":{"x":x,"y":y,"z":z}}
    Devuelve data_cut en el mismo formato OUTGEOM.
    """
    G = data["graph"]
    x = np.asarray(data["coords"]["x"], dtype=np.float32)
    y = np.asarray(data["coords"]["y"], dtype=np.float32)
    z = np.asarray(data["coords"]["z"], dtype=np.float32)

    # --- preparar nuevo grafo H ---
    H = ig.Graph()
    H.add_vertices(0)

    # Copiamos lista de atributos (excepto los que vamos a recalcular)
    v_attrs = list(G.vs.attributes())
    e_attrs = list(G.es.attributes())

    # Mapa old_vid -> new_vid (solo para los que queden dentro)
    old2new = {}

    coords_v = np.asarray(G.vs["coords"], dtype=np.float32)
    inside_v = (
        (coords_v[:,0] >= xBox[0]) & (coords_v[:,0] <= xBox[1]) &
        (coords_v[:,1] >= yBox[0]) & (coords_v[:,1] <= yBox[1]) &
        (coords_v[:,2] >= zBox[0]) & (coords_v[:,2] <= zBox[1])
    )

    # Añadimos primero los vértices interiores (igual que Gaia: solo lo que queda en el subgrafo)
    inside_old_ids = np.where(inside_v)[0]
    H.add_vertices(len(inside_old_ids))
    for new_i, old_i in enumerate(inside_old_ids):
        old2new[int(old_i)] = int(new_i)
        for a in v_attrs:
            # inicializa atributos por vertex (luego asignamos)
            pass

    # Copiar atributos de vertices interiores (vectorizado por listas)
    for a in v_attrs:
        vals = [G.vs[int(i)][a] for i in inside_old_ids]
        H.vs[a] = vals

    # Hash para nodos frontera (intersecciones) para no duplicar
    border_key2new = {}

    # Nuevos arrays globales de geometría
    new_x = []
    new_y = []
    new_z = []
    new_geom_start = []
    new_geom_end = []

    # Almacenamos edges y sus atributos (para añadir al final)
    new_edges = []
    new_edge_attr = {a: [] for a in e_attrs if a not in ["geom_start", "geom_end"]}
    # Recalculamos también length_tortuous / tortuosity si existen o si quieres
    want_length_tort = True

    # ---------------------------------------------------------
    # iterar edges
    # ---------------------------------------------------------
    for e in G.es:
        u = int(e.source)
        v = int(e.target)
        s = int(e["geom_start"])
        en = int(e["geom_end"])
        if en - s < 2:
            continue

        # slice de puntos del edge (temporal)
        P = np.column_stack([x[s:en], y[s:en], z[s:en]]).astype(np.float32, copy=False)

        # Orientación coherente con el edge: P[0] debería coincidir con coords del source
        cu = np.asarray(G.vs[u]["coords"], dtype=np.float32)
        if not np.allclose(P[0], cu, atol=1e-5):
            # entonces P está en dirección v->u, lo invertimos para que sea u->v
            P = P[::-1].copy()

        u_in = bool(inside_v[u])
        v_in = bool(inside_v[v])

        # Caso A: ambos dentro => copiamos edge completo
        if u_in and v_in:
            uu = old2new[u]
            vv = old2new[v]

            start_idx = len(new_x)
            new_x.extend(P[:,0].tolist())
            new_y.extend(P[:,1].tolist())
            new_z.extend(P[:,2].tolist())
            end_idx = len(new_x)

            new_edges.append((uu, vv))
            new_geom_start.append(start_idx)
            new_geom_end.append(end_idx)

            # copiar atributos edge (excepto geom_*)
            for a in new_edge_attr.keys():
                new_edge_attr[a].append(e[a])

            continue

        # Caso B: ambos fuera => descartamos
        if (not u_in) and (not v_in):
            continue

        # Caso C: cruza borde => recorte Gaia-like
        # mask de puntos dentro
        inside_mask = is_inside_box_np(P, xBox, yBox, zBox)
        if not np.any(inside_mask):
            # aunque uno de los vertices sea "inside" por coords, puede pasar si coords no coincide con P por algún bug
            continue

        # Queremos quedarnos con el tramo interno conectado al vértice interno
        # Si u está dentro => buscamos transición desde el inicio
        # Si v está dentro => buscamos transición desde el final
        if u_in:
            # tramo interior empieza en 0
            # buscamos primer punto que salga
            # transición i -> i+1 donde inside cambia 1->0
            diff = np.diff(inside_mask.astype(np.int8))
            cut_idx = np.where(diff == -1)[0]
            if len(cut_idx) == 0:
                # todo dentro (por geometría) aunque v no esté dentro por coords; nos quedamos con todo
                P_keep = P
                inter = None
            else:
                i = int(cut_idx[0])
                p_in = P[i]
                p_out = P[i+1]
                inter = segment_box_intersection(p_in, p_out, xBox, yBox, zBox)
                if inter is None:
                    continue
                P_keep = np.vstack([P[:i+1], inter.astype(np.float32)])

            uu = old2new[u]

            # crear/reusar nodo frontera
            if inter is None:
                # raro: no hay intersección, pero si v está fuera, aún así mantenemos P_keep y conectamos a v?
                # Mejor: creamos nodo frontera en último punto de P_keep
                inter = P_keep[-1]
            key = quant_key(inter, tol=tol)
            if key in border_key2new:
                ww = border_key2new[key]
            else:
                ww = H.vcount()
                H.add_vertices(1)
                border_key2new[key] = ww
                # copiar atributos de vertex desde el interior (o inicializar)
                for a in v_attrs:
                    if a == "coords":
                        H.vs[ww][a] = tuple(map(float, inter))
                    else:
                        # estrategia segura: si existe el atributo, clonamos del nodo interior
                        H.vs[ww][a] = H.vs[uu][a] if a in H.vs.attributes() else None

            start_idx = len(new_x)
            new_x.extend(P_keep[:,0].tolist())
            new_y.extend(P_keep[:,1].tolist())
            new_z.extend(P_keep[:,2].tolist())
            end_idx = len(new_x)

            new_edges.append((uu, ww))
            new_geom_start.append(start_idx)
            new_geom_end.append(end_idx)

            for a in new_edge_attr.keys():
                new_edge_attr[a].append(e[a])

        else:
            # v_in == True, tramo interior acaba en el final
            diff = np.diff(inside_mask.astype(np.int8))
            cut_idx = np.where(diff == 1)[0]  # 0->1 entrando al box
            if len(cut_idx) == 0:
                P_keep = P
                inter = None
            else:
                i = int(cut_idx[-1])  # última entrada
                p_out = P[i]
                p_in = P[i+1]
                inter = segment_box_intersection(p_in, p_out, xBox, yBox, zBox)
                if inter is None:
                    continue
                # mantenemos desde i+1 hasta final, pero con inter delante
                P_keep = np.vstack([inter.astype(np.float32), P[i+1:]])

            vv = old2new[v]

            if inter is None:
                inter = P_keep[0]
            key = quant_key(inter, tol=tol)
            if key in border_key2new:
                ww = border_key2new[key]
            else:
                ww = H.vcount()
                H.add_vertices(1)
                border_key2new[key] = ww
                for a in v_attrs:
                    if a == "coords":
                        H.vs[ww][a] = tuple(map(float, inter))
                    else:
                        H.vs[ww][a] = H.vs[vv][a] if a in H.vs.attributes() else None

            start_idx = len(new_x)
            new_x.extend(P_keep[:,0].tolist())
            new_y.extend(P_keep[:,1].tolist())
            new_z.extend(P_keep[:,2].tolist())
            end_idx = len(new_x)

            new_edges.append((ww, vv))
            new_geom_start.append(start_idx)
            new_geom_end.append(end_idx)

            for a in new_edge_attr.keys():
                new_edge_attr[a].append(e[a])

    # Añadir edges al grafo y setear atributos
    H.add_edges(new_edges)

    # geom indices
    H.es["geom_start"] = list(map(int, new_geom_start))
    H.es["geom_end"]   = list(map(int, new_geom_end))

    # copiar atributos
    for a, vals in new_edge_attr.items():
        H.es[a] = vals

    # Recalcular length_tortuous / tortuosity (barato porque ya tenemos geom indices)
    if want_length_tort:
        nx = np.asarray(new_x, dtype=np.float32)
        ny = np.asarray(new_y, dtype=np.float32)
        nz = np.asarray(new_z, dtype=np.float32)

        lt = np.zeros(H.ecount(), dtype=np.float32)
        sd = np.zeros(H.ecount(), dtype=np.float32)

        for ei in range(H.ecount()):
            s = H.es[ei]["geom_start"]
            en = H.es[ei]["geom_end"]
            if en - s < 2:
                continue
            dx = np.diff(nx[s:en])
            dy = np.diff(ny[s:en])
            dz = np.diff(nz[s:en])
            lt[ei] = np.sum(np.sqrt(dx*dx + dy*dy + dz*dz))
            sd[ei] = np.sqrt((nx[en-1]-nx[s])**2 + (ny[en-1]-ny[s])**2 + (nz[en-1]-nz[s])**2)

        tort = np.full(H.ecount(), np.nan, dtype=np.float32)
        mask = sd >= float(min_straight_dist)
        tort[mask] = lt[mask] / sd[mask]
        H.es["length_tortuous"] = lt.tolist()
        H.es["tortuosity"] = tort.tolist()

    # limpiar vértices aislados
    iso = [v.index for v in H.vs if H.degree(v) == 0]
    if iso:
        H.delete_vertices(iso)

    out = {
        "graph": H,
        "coords": {
            "x": np.asarray(new_x, dtype=np.float32),
            "y": np.asarray(new_y, dtype=np.float32),
            "z": np.asarray(new_z, dtype=np.float32),
        }
    }
    return out

# --------------------------
# Example usage
# --------------------------
if __name__ == "__main__":
    in_path  = "/home/admin/Ana/MicroBrain/output/graph_18_OutGeom.pkl"
    out_path = "/home/admin/Ana/MicroBrain/output/graph_18_OutGeom_CUT.pkl"

    with open(in_path, "rb") as f:
        data = pickle.load(f)

    # ejemplo de box en µm
    xBox = [1000*1.625, 2000*1.625]
    yBox = [0*1.625,    1000*1.625]
    zBox = [1500*2.5,   2500*2.5]

    cut = cut_outgeom_gaia_like(data, xBox, yBox, zBox, tol=1e-3, min_straight_dist=1.0)

    with open(out_path, "wb") as f:
        pickle.dump(cut, f, protocol=pickle.HIGHEST_PROTOCOL)

    print("Saved:", out_path, "Vertices:", cut["graph"].vcount(), "Edges:", cut["graph"].ecount())
